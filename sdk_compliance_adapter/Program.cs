using System.Collections.Concurrent;
using System.IO.Compression;
using System.Text.Json;
using System.Text.Json.Serialization;
using PostHog;
using PostHog.Versioning;

var builder = WebApplication.CreateBuilder(args);

// Configure JSON options for consistent serialization
builder.Services.ConfigureHttpJsonOptions(options =>
{
    options.SerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower;
    options.SerializerOptions.DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull;
});

var app = builder.Build();

// Global state for the adapter
var state = new AdapterState();

app.MapGet("/health", () => new HealthResponse(
    SdkName: "posthog-dotnet",
    SdkVersion: VersionConstants.Version,
    AdapterVersion: "1.0.0"
));

app.MapPost("/init", async (InitRequest request) =>
{
    await state.ResetAsync();

    state.ApiKey = request.ApiKey;
    state.Host = request.Host;
    state.FlushAt = request.FlushAt ?? 100;
    state.FlushIntervalMs = request.FlushIntervalMs ?? 500;

    var options = new PostHogOptions
    {
        ProjectApiKey = request.ApiKey,
        HostUrl = new Uri(request.Host),
        FlushAt = state.FlushAt,
        FlushInterval = TimeSpan.FromMilliseconds(state.FlushIntervalMs),
        MaxBatchSize = 100,
        MaxQueueSize = 1000,
        MaxRetries = request.MaxRetries ?? 3
    };

    // Only set EnableCompression if explicitly provided; otherwise use SDK default (true)
    if (request.EnableCompression is { } compression)
    {
        options.EnableCompression = compression;
    }

    // Create a new tracked HTTP client factory for each init
    var httpClientFactory = new TrackedHttpClientFactory(state);
    state.HttpClientFactory = httpClientFactory;
    state.Client = new PostHogClient(options, httpClientFactory: httpClientFactory);

    return Results.Ok(new { success = true });
});

app.MapPost("/capture", (CaptureRequest request) =>
{
    if (state.Client is null)
    {
        return Results.BadRequest(new { error = "SDK not initialized" });
    }

    if (string.IsNullOrEmpty(request.DistinctId) || string.IsNullOrEmpty(request.Event))
    {
        return Results.BadRequest(new { error = "distinct_id and event are required" });
    }

    DateTimeOffset? timestamp = null;
    if (!string.IsNullOrEmpty(request.Timestamp))
    {
        if (DateTimeOffset.TryParse(request.Timestamp, out var parsed))
        {
            timestamp = parsed;
        }
    }

    // SDK now generates UUID internally
    var success = state.Client.Capture(
        request.DistinctId,
        request.Event,
        request.Properties,
        groups: null,
        sendFeatureFlags: false,
        timestamp: timestamp
    );

    if (!success)
    {
        return Results.StatusCode(500);
    }

    // Only track after successful enqueue
    state.TrackCapturedEvent();

    // UUID is generated by the SDK and included in the batch; this endpoint only returns success
    return Results.Ok(new { success = true });
});

app.MapPost("/flush", async () =>
{
    if (state.Client is null)
    {
        return Results.BadRequest(new { error = "SDK not initialized" });
    }

    try
    {
        await state.Client.FlushAsync();

        // Wait a bit for any pending requests to complete
        await Task.Delay(100);
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"Flush error: {ex}");
        state.RecordError(ex.Message);
    }

    return Results.Ok(new { success = true, events_flushed = state.TotalEventsSent });
});

app.MapGet("/state", () =>
{
    return Results.Ok(new StateResponse(
        PendingEvents: Math.Max(0, state.TotalEventsCaptured - state.TotalEventsSent),
        TotalEventsCaptured: state.TotalEventsCaptured,
        TotalEventsSent: state.TotalEventsSent,
        TotalRetries: 0, // SDK doesn't expose retry events
        LastError: state.LastError,
        RequestsMade: state.RequestsMade.ToList()
    ));
});

app.MapPost("/reset", async () =>
{
    await state.ResetAsync();
    return Results.Ok(new { success = true });
});

app.Run();

// --- Models ---

record HealthResponse(
    [property: JsonPropertyName("sdk_name")] string SdkName,
    [property: JsonPropertyName("sdk_version")] string SdkVersion,
    [property: JsonPropertyName("adapter_version")] string AdapterVersion
);

record InitRequest(
    [property: JsonPropertyName("api_key")] string ApiKey,
    [property: JsonPropertyName("host")] string Host,
    [property: JsonPropertyName("flush_at")] int? FlushAt = null,
    [property: JsonPropertyName("flush_interval_ms")] int? FlushIntervalMs = null,
    [property: JsonPropertyName("max_retries")] int? MaxRetries = null,
    [property: JsonPropertyName("enable_compression")] bool? EnableCompression = null
);

record CaptureRequest(
    [property: JsonPropertyName("distinct_id")] string DistinctId,
    [property: JsonPropertyName("event")] string Event,
    [property: JsonPropertyName("properties")] Dictionary<string, object>? Properties = null,
    [property: JsonPropertyName("timestamp")] string? Timestamp = null
);

record StateResponse(
    [property: JsonPropertyName("pending_events")] int PendingEvents,
    [property: JsonPropertyName("total_events_captured")] int TotalEventsCaptured,
    [property: JsonPropertyName("total_events_sent")] int TotalEventsSent,
    [property: JsonPropertyName("total_retries")] int TotalRetries,
    [property: JsonPropertyName("last_error")] string? LastError,
    [property: JsonPropertyName("requests_made")] List<RequestInfo> RequestsMade
);

record RequestInfo(
    [property: JsonPropertyName("timestamp_ms")] long TimestampMs,
    [property: JsonPropertyName("status_code")] int StatusCode,
    [property: JsonPropertyName("retry_attempt")] int RetryAttempt,
    [property: JsonPropertyName("event_count")] int EventCount,
    [property: JsonPropertyName("uuid_list")] List<string> UuidList
);

// --- Adapter State ---

class AdapterState
{
    readonly object _lock = new();

    public PostHogClient? Client { get; set; }
    public TrackedHttpClientFactory? HttpClientFactory { get; set; }
    public string? ApiKey { get; set; }
    public string? Host { get; set; }
    public int FlushAt { get; set; } = 100;
    public int FlushIntervalMs { get; set; } = 500;

    public int TotalEventsCaptured { get; private set; }
    public int TotalEventsSent { get; private set; }
    public string? LastError { get; private set; }

    readonly ConcurrentBag<RequestInfo> _requestsMade = [];
    public IReadOnlyCollection<RequestInfo> RequestsMade => _requestsMade;

    public void TrackCapturedEvent()
    {
        lock (_lock)
        {
            TotalEventsCaptured++;
        }
    }

    public void RecordRequest(int statusCode, int eventCount, List<string> uuids, int retryAttempt = 0)
    {
        lock (_lock)
        {
            _requestsMade.Add(new RequestInfo(
                TimestampMs: DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),
                StatusCode: statusCode,
                RetryAttempt: retryAttempt,
                EventCount: eventCount,
                UuidList: uuids
            ));

            if (statusCode is >= 200 and < 300)
            {
                TotalEventsSent += eventCount;
            }
        }
    }

    public void RecordError(string error)
    {
        lock (_lock)
        {
            LastError = error;
        }
    }

    public async Task ResetAsync()
    {
        // Dispose client first
        if (Client is not null)
        {
            try
            {
                await Client.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
            Client = null;
        }

        // Dispose http client factory
        HttpClientFactory?.Dispose();
        HttpClientFactory = null;

        lock (_lock)
        {
            ApiKey = null;
            Host = null;
            FlushAt = 100;
            FlushIntervalMs = 500;
            TotalEventsCaptured = 0;
            TotalEventsSent = 0;
            LastError = null;
        }

        // Clear collections
        while (_requestsMade.TryTake(out _)) { }
    }
}

// --- HTTP Client Factory and Handler ---

class TrackedHttpClientFactory : IHttpClientFactory, IDisposable
{
    readonly AdapterState _state;
    readonly HttpClient _httpClient;
    readonly TrackedHttpMessageHandler _handler;
    bool _disposed;

    public TrackedHttpClientFactory(AdapterState state)
    {
        _state = state;
        _handler = new TrackedHttpMessageHandler(state);
        _httpClient = new HttpClient(_handler, disposeHandler: false);
    }

    public HttpClient CreateClient(string name)
    {
        if (_disposed)
        {
            throw new ObjectDisposedException(nameof(TrackedHttpClientFactory));
        }
        return _httpClient;
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            _disposed = true;
            _httpClient.Dispose();
            _handler.Dispose();
        }
    }
}

class TrackedHttpMessageHandler : DelegatingHandler
{
    readonly AdapterState _state;

    public TrackedHttpMessageHandler(AdapterState state)
        : base(new HttpClientHandler())
    {
        _state = state;
    }

    protected override async Task<HttpResponseMessage> SendAsync(
        HttpRequestMessage request,
        CancellationToken cancellationToken)
    {
        // Read request body to extract UUIDs
        var uuids = new List<string>();
        var eventCount = 0;

        if (request.Content is not null)
        {
            var originalContentType = request.Content.Headers.ContentType;
            var originalContentEncoding = request.Content.Headers.ContentEncoding.ToList();
            var bodyBytes = await request.Content.ReadAsByteArrayAsync(cancellationToken);

            // Restore content for the actual request, preserving headers
            request.Content = new ByteArrayContent(bodyBytes);
            if (originalContentType is not null)
            {
                request.Content.Headers.ContentType = originalContentType;
            }
            foreach (var encoding in originalContentEncoding)
            {
                request.Content.Headers.ContentEncoding.Add(encoding);
            }

            // Decompress if gzip (case-insensitive per HTTP spec)
            var isGzipped = originalContentEncoding.Any(e => string.Equals(e, "gzip", StringComparison.OrdinalIgnoreCase));
            var jsonBytes = isGzipped
                ? await GzipHelper.DecompressGzipAsync(bodyBytes, cancellationToken)
                : bodyBytes;

            // Parse body to extract UUIDs from top-level uuid field
            try
            {
                using var doc = JsonDocument.Parse(jsonBytes);
                if (doc.RootElement.TryGetProperty("batch", out var batch) && batch.ValueKind == JsonValueKind.Array)
                {
                    foreach (var evt in batch.EnumerateArray())
                    {
                        eventCount++;
                        // Check for uuid field at top level (SDK now puts it there)
                        if (evt.TryGetProperty("uuid", out var directUuid))
                        {
                            uuids.Add(directUuid.GetString() ?? "");
                        }
                    }
                }
            }
            catch
            {
                // Ignore parsing errors
            }
        }

        // Make the actual request
        var response = await base.SendAsync(request, cancellationToken);

        // Record the request
        _state.RecordRequest((int)response.StatusCode, eventCount, uuids);

        if (!response.IsSuccessStatusCode)
        {
            try
            {
                var errorBody = await response.Content.ReadAsStringAsync(cancellationToken);
                _state.RecordError($"HTTP {(int)response.StatusCode}: {errorBody}");
            }
            catch
            {
                _state.RecordError($"HTTP {(int)response.StatusCode}");
            }
        }

        return response;
    }
}

static class GzipHelper
{
    public static async Task<byte[]> DecompressGzipAsync(byte[] compressedBytes, CancellationToken cancellationToken)
    {
        using var compressedStream = new MemoryStream(compressedBytes);
        using var gzipStream = new GZipStream(compressedStream, CompressionMode.Decompress);
        using var decompressedStream = new MemoryStream();
        await gzipStream.CopyToAsync(decompressedStream, cancellationToken);
        return decompressedStream.ToArray();
    }
}
